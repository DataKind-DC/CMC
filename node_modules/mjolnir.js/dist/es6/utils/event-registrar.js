import { whichButtons, getOffsetPosition } from './event-utils';
var DEFAULT_OPTIONS = {
  srcElement: 'root',
  priority: 0
};
export default class EventRegistrar {
  constructor(eventManager) {
    this.eventManager = eventManager;
    this.handlers = [];
    this.handlersByElement = new Map();
    this.handleEvent = this.handleEvent.bind(this);
    this._active = false;
  }

  isEmpty() {
    return !this._active;
  }

  add(type, handler, opts) {
    var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var passive = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var {
      handlers,
      handlersByElement
    } = this;

    if (opts && (typeof opts !== 'object' || opts.addEventListener)) {
      opts = {
        srcElement: opts
      };
    }

    opts = opts ? Object.assign({}, DEFAULT_OPTIONS, opts) : DEFAULT_OPTIONS;
    var entries = handlersByElement.get(opts.srcElement);

    if (!entries) {
      entries = [];
      handlersByElement.set(opts.srcElement, entries);
    }

    var entry = {
      type,
      handler,
      srcElement: opts.srcElement,
      priority: opts.priority
    };

    if (once) {
      entry.once = true;
    }

    if (passive) {
      entry.passive = true;
    }

    handlers.push(entry);
    this._active = this._active || !entry.passive;
    var insertPosition = entries.length - 1;

    while (insertPosition >= 0) {
      if (entries[insertPosition].priority >= entry.priority) {
        break;
      }

      insertPosition--;
    }

    entries.splice(insertPosition + 1, 0, entry);
  }

  remove(type, handler) {
    var {
      handlers,
      handlersByElement
    } = this;

    for (var i = handlers.length - 1; i >= 0; i--) {
      var entry = handlers[i];

      if (entry.type === type && entry.handler === handler) {
        handlers.splice(i, 1);
        var entries = handlersByElement.get(entry.srcElement);
        entries.splice(entries.indexOf(entry), 1);

        if (entries.length === 0) {
          handlersByElement.delete(entry.srcElement);
        }
      }
    }

    this._active = handlers.some(entry => !entry.passive);
  }

  handleEvent(event) {
    if (this.isEmpty()) {
      return;
    }

    var mjolnirEvent = this._normalizeEvent(event);

    var target = event.srcEvent.target;

    while (target && target !== mjolnirEvent.rootElement) {
      this._emit(mjolnirEvent, target);

      if (mjolnirEvent.handled) {
        return;
      }

      target = target.parentNode;
    }

    this._emit(mjolnirEvent, 'root');
  }

  _emit(event, srcElement) {
    var entries = this.handlersByElement.get(srcElement);

    if (entries) {
      var immediatePropagationStopped = false;

      var stopPropagation = () => {
        event.handled = true;
      };

      var stopImmediatePropagation = () => {
        event.handled = true;
        immediatePropagationStopped = true;
      };

      var entriesToRemove = [];

      for (var i = 0; i < entries.length; i++) {
        var {
          type,
          handler,
          once
        } = entries[i];
        handler(Object.assign({}, event, {
          type,
          stopPropagation,
          stopImmediatePropagation
        }));

        if (once) {
          entriesToRemove.push(entries[i]);
        }

        if (immediatePropagationStopped) {
          break;
        }
      }

      for (var _i = 0; _i < entriesToRemove.length; _i++) {
        var {
          type: _type,
          handler: _handler
        } = entriesToRemove[_i];
        this.remove(_type, _handler);
      }
    }
  }

  _normalizeEvent(event) {
    var rootElement = this.eventManager.element;
    return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, rootElement), {
      handled: false,
      rootElement
    });
  }

}
//# sourceMappingURL=event-registrar.js.map